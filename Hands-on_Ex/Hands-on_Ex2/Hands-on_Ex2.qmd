---
title: "Hands-on_Ex2"
date: "23 November 2023"
date-modified: "last-modified"
---

# Spatial Weights and Application

## Overview 

Computing spatial weights

Library utilised: sf, readr, dplyr, and spded (compute spatial weight and spatially lagged variables)

## Dataset

The dataset used for this part is Hunan_2012.csv which contains selected Hunan's local development indacators in 2012.

### Getting Started

Importing the needed librarty

```{r}
pacman::p_load(sf, spdep, tmap, tidyverse, knitr)
```

## Importing Data to R Environment

### Import shapefile into R 

utilising st_read of sf to read shapefile

```{r}
hunan <- st_read(dsn = "data/geospatial",
                 layer = "Hunan")
```

### Importing CSV file to R

using read_csv

```{r}
hunan2012 <- read_csv("data/aspatial/Hunan_2012.csv")
```

### Joining Dataset

using left_join() from dplyr join the shapefile data and csv file of Hunan and selecting relevant columns for plotting

```{r}
hunan <- left_join(hunan,hunan2012)%>%
  select(1:4, 7, 15)
```

```{r}
hunan
```

## Visualising Regional Developement Indicator

plotting usint tmap

```{r}
basemap <- tm_shape(hunan) +
  tm_polygons() +
  tm_text("NAME_3", size=0.3)

gdppc <- qtm(hunan, "GDPPC")
tmap_arrange(basemap, gdppc, asp=1, ncol=2)
```

## Computing Contiguity Spatial Weights

We are going to compute contiguity spatial weight, which is calculating neighbour based on the boundaries. We are going to try both queen and rook method here. To implement this, we are going to utilise poly2nb() of sdpep package.

### Queen

```{r}
wm_q <- poly2nb(hunan, queen=TRUE)
summary(wm_q)
```

the boundaries neighbour was keeped in the wm variable as the summary shown above

the first line of numbers is the number of connection / neighbour, the second line of numbers is the number of region with x amount of connection or neighbour.

```{r}
wm_q[[1]]
```

```{r}
hunan$County[1]
```

```{r}
hunan$NAME_3[c(2,3,4,57,85)]
```

\^ above is how to find the neighbour of region "1" or Anxiang

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

\^ showing the gdp per capita of region neighbouring with anxiang

```{r}
str(wm_q)
```

\^ list all the nearest neighbour of the regions

### Rook

```{r}
wm_r <- poly2nb(hunan, queen=FALSE)
summary(wm_r)
```

### Visualising

getting the longitude and latitude

utilising :

\- map_dbl() \<- mapping or applying function toward vector

\- st_centroid \<- getting the centroid of the geometry

```{r}
longitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[1]])
```

```{r}
latitude <- map_dbl(hunan$geometry, ~st_centroid(.x)[[2]])
```

zipping the longitude and latitude together

```{r}
coords <- cbind(longitude, latitude)
```

```{r}
head(coords)
```

Plotting queen

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
```

plotting rook

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

plotting side by side

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="Queen Contiguity")
plot(wm_q, coords, pch = 19, cex = 0.6, add = TRUE, col= "red")
plot(hunan$geometry, border="lightgrey", main="Rook Contiguity")
plot(wm_r, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

## Distance Based Neighbour

utilising dnearneigh() from spdep package. it used euclidean distance

### determine cutoff distance

since it used distance we need to give the range of the distance for calculation

```{r}
#coords <- coordinates(hunan)
k1 <- knn2nb(knearneigh(coords))
k1dists <- unlist(nbdists(k1, coords, longlat = TRUE))
summary(k1dists)
```

### **Computing fixed distance weight matrix**

```{r}
wm_d62 <- dnearneigh(coords, 0, 62, longlat = TRUE)
wm_d62
```

```{r}
str(wm_d62)
```

```{r}
table(hunan$County, card(wm_d62))
```

```{r}
n_comp <- n.comp.nb(wm_d62)
n_comp$nc
```

```{r}
table(n_comp$comp.id)
```

#### plotting fixed distance weight matrix

```{r}
plot(hunan$geometry, border="lightgrey")
plot(wm_d62, coords, add=TRUE)
plot(k1, coords, add=TRUE, col="red", length=0.08)
```

```{r}
par(mfrow=c(1,2))
plot(hunan$geometry, border="lightgrey", main="1st nearest neighbours")
plot(k1, coords, add=TRUE, col="red", length=0.08)
plot(hunan$geometry, border="lightgrey", main="Distance link")
plot(wm_d62, coords, add=TRUE, pch = 19, cex = 0.6)
```

### Computing adaptive distance weight matrix

creating neighbours using KNN with knn2nb fucntion with K=6

```{r}
knn6 <- knn2nb(knearneigh(coords,k=6))
knn6
```

```{r}
str(knn6)
```

#### Plotting

```{r}
plot(hunan$geometry, border="lightgrey")
plot(knn6, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")
```

## IDW based weight

inverse distance method using nbdists() of spdep

```{r}
dist <- nbdists(wm_q, coords, longlat = TRUE)
ids <- lapply(dist, function(x) 1/(x))
ids
```

### Row-standardised weight matrix

```{r}
rswm_q <- nb2listw(wm_q, style="W", zero.policy = TRUE)
rswm_q
```

```{r}
rswm_q$weights[10]
```

```{r}
rswm_ids <- nb2listw(wm_q, glist=ids, style="B", zero.policy=TRUE)
rswm_ids
```

```{r}
rswm_ids$weights[1]
```

```{r}
summary(unlist(rswm_ids$weights))
```

## Application of Spatial Weight Matrix

### Spatial lag with row-standardized weights

compute the avg neighbor gdp per capita (often referred spatially lagged values)

```{r}
GDPPC.lag <- lag.listw(rswm_q, hunan$GDPPC)
GDPPC.lag
```

```{r}
nb1 <- wm_q[[1]]
nb1 <- hunan$GDPPC[nb1]
nb1
```

```{r}
lag.list <- list(hunan$NAME_3, lag.listw(rswm_q, hunan$GDPPC))
lag.res <- as.data.frame(lag.list)
colnames(lag.res) <- c("NAME_3", "lag GDPPC")
hunan <- left_join(hunan,lag.res)
```

```{r}
head(hunan)
```

```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_gdppc <- qtm(hunan, "lag GDPPC")
tmap_arrange(gdppc, lag_gdppc, asp=1, ncol=2)
```

### Spatial lag as a sum of neighboring values

```{r}
b_weights <- lapply(wm_q, function(x) 0*x + 1)
b_weights2 <- nb2listw(wm_q, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

```{r}
lag_sum <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
lag.res <- as.data.frame(lag_sum)
colnames(lag.res) <- c("NAME_3", "lag_sum GDPPC")
```

```{r}
lag_sum
```

joining hunan and lag

```{r}
hunan <- left_join(hunan, lag.res)
```

```{r}
gdppc <- qtm(hunan, "GDPPC")
lag_sum_gdppc <- qtm(hunan, "lag_sum GDPPC")
tmap_arrange(gdppc, lag_sum_gdppc, asp=1, ncol=2)
```

### Spatial window average

```{r}
wm_qs <- include.self(wm_q)
```

```{r}
wm_qs[[1]]
```

```{r}
wm_qs <- nb2listw(wm_qs)
wm_qs
```

```{r}
lag_w_avg_gpdpc <- lag.listw(wm_qs, 
                             hunan$GDPPC)
lag_w_avg_gpdpc
```

```{r}
lag.list.wm_qs <- list(hunan$NAME_3, lag.listw(wm_qs, hunan$GDPPC))
lag_wm_qs.res <- as.data.frame(lag.list.wm_qs)
colnames(lag_wm_qs.res) <- c("NAME_3", "lag_window_avg GDPPC")
```

```{r}
hunan <- left_join(hunan, lag_wm_qs.res)
```

```{r}
hunan %>%
  select("County", 
         "lag GDPPC", 
         "lag_window_avg GDPPC") %>%
  kable()
```

```{r}
w_avg_gdppc <- qtm(hunan, "lag_window_avg GDPPC")
tmap_arrange(lag_gdppc, w_avg_gdppc, asp=1, ncol=2)
```

### Spatial window sum

```{r}
wm_qs <- include.self(wm_q)
wm_qs
```

```{r}
b_weights <- lapply(wm_qs, function(x) 0*x + 1)
b_weights[1]
```

```{r}
b_weights2 <- nb2listw(wm_qs, 
                       glist = b_weights, 
                       style = "B")
b_weights2
```

```{r}
w_sum_gdppc <- list(hunan$NAME_3, lag.listw(b_weights2, hunan$GDPPC))
w_sum_gdppc
```

```{r}
w_sum_gdppc.res <- as.data.frame(w_sum_gdppc)
colnames(w_sum_gdppc.res) <- c("NAME_3", "w_sum GDPPC")
```

```{r}
hunan <- left_join(hunan, w_sum_gdppc.res)
```

```{r}
hunan %>%
  select("County", "lag_sum GDPPC", "w_sum GDPPC") %>%
  kable()
```

```{r}
w_sum_gdppc <- qtm(hunan, "w_sum GDPPC")
tmap_arrange(lag_sum_gdppc, w_sum_gdppc, asp=1, ncol=2)
```
